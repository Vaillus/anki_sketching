<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Anki Sketching</title>
    <style>
        body { 
            font-family: sans-serif; 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            /* Emp√™che le zoom accidentel du navigateur */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        #toolbar { 
            position: fixed; 
            top: 10px; 
            left: 10px; 
            z-index: 10000; 
            background: white; 
            padding: 15px; 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            border: 1px solid #ccc;
            /* Emp√™che les interactions accidentelles */
            pointer-events: auto;
            /* R√©active la s√©lection de texte dans la barre d'outils */
            -webkit-user-select: auto;
            -moz-user-select: auto;
            -ms-user-select: auto;
            user-select: auto;
        }
        
        #zoom-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10000;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            border: 1px solid #ccc;
            pointer-events: auto;
            -webkit-user-select: auto;
            -moz-user-select: auto;
            -ms-user-select: auto;
            user-select: auto;
        }
        
        #zoom-controls button {
            margin: 0 5px;
            padding: 5px 10px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #canvas-container { 
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
        }
        
        #canvas-container.dragging {
            cursor: grabbing;
        }
        
        #canvas {
            position: absolute;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }
        
        .card-box {
            position: absolute;
            border: 3px solid #ccc;
            border-radius: 8px;
            padding: 1em;
            width: 300px;
            height: 200px;
            overflow: auto;
            background-color: white;
            cursor: move;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: left 0.3s ease-out, top 0.3s ease-out, border-color 0.2s ease;
        }
        
        .card-box.selected {
            border-color: #4CAF50;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }
        
        .card-box:hover {
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .card-box img { 
            max-width: 100%; 
            height: auto; 
        }
        
        #info-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 10000;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: auto;
            -webkit-user-select: auto;
            -moz-user-select: auto;
            -ms-user-select: auto;
            user-select: auto;
        }
        
        #context-menu {
            position: fixed;
            z-index: 10001;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            padding: 0;
            min-width: 150px;
            display: none;
        }
        
        #context-menu .menu-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 14px;
        }
        
        #context-menu .menu-item:last-child {
            border-bottom: none;
        }
        
        #context-menu .menu-item:hover {
            background-color: #f0f0f0;
        }
        
        #selection-toolbar {
            position: fixed;
            bottom: 60px;
            left: 10px;
            z-index: 10000;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            border: 1px solid #ccc;
            display: none;
        }
        
        #selection-toolbar button {
            margin-right: 10px;
            padding: 8px 12px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #selection-toolbar button:hover {
            background-color: #f0f0f0;
        }
        
        .group-box {
            position: absolute;
            border: 2px dashed #2196F3;
            border-radius: 12px;
            background-color: rgba(33, 150, 243, 0.1);
            z-index: 1;
            pointer-events: auto;
            cursor: move;
            transition: all 0.3s ease;
        }
        
        .group-box.selected {
            border-color: #FF5722;
            background-color: rgba(255, 87, 34, 0.1);
        }
        
        .group-box.dragging {
            border-color: #FF9800;
            background-color: rgba(255, 152, 0, 0.2);
        }
        
        .group-label {
            position: absolute;
            top: -8px;
            left: 10px;
            background-color: #2196F3;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            pointer-events: auto;
            cursor: pointer;
        }
        
        .group-label.selected {
            background-color: #FF5722;
        }
    </style>
</head>
<body>

    <div id="toolbar">
        <h3 style="margin: 0 0 10px 0;">Anki Sketching</h3>
        <form id="import-form">
            <select id="deck-name" name="deck_name" required>
                <option value="" disabled selected>Choisir un paquet</option>
                {% for deck in decks %}
                <option value="{{ deck }}">{{ deck }}</option>
                {% endfor %}
            </select>
            <button type="submit">Importer</button>
        </form>
        <div style="margin-top: 10px;">
            <button id="save-positions" type="button">üíæ Sauvegarder positions</button>
            <button id="clear-canvas" type="button" style="margin-left: 10px;">üóëÔ∏è Vider le canvas</button>
        </div>
    </div>

    <div id="zoom-controls">
        <button id="zoom-in">+</button>
        <span id="zoom-level">100%</span>
        <button id="zoom-out">-</button>
        <button id="reset-view">Reset</button>
    </div>

    <div id="canvas-container">
        <div id="canvas">
            <!-- Les cartes seront ajout√©es ici -->
        </div>
    </div>

    <div id="info-panel">
        Position: <span id="position">0, 0</span> | Zoom: <span id="zoom-info">100%</span>
    </div>

    <!-- Menu contextuel -->
    <div id="context-menu">
        <div class="menu-item" id="context-deselect">D√©s√©lectionner</div>
        <div class="menu-item" id="context-delete">Supprimer la carte</div>
        <div class="menu-item" id="context-bring-front">Mettre au premier plan</div>
    </div>

    <!-- Barre d'outils de s√©lection -->
    <div id="selection-toolbar">
        <span id="selection-count">0 carte(s) s√©lectionn√©e(s)</span>
        <button id="group-selected">üîó Grouper</button>
        <button id="deselect-all">‚ùå Tout d√©s√©lectionner</button>
    </div>

    <script>
        // Variables globales pour le canvas
        let canvasX = 0, canvasY = 0, zoom = 1;
        let isDraggingCanvas = false;
        let lastMouseX = 0, lastMouseY = 0;
        let cardCounter = 0;
        let cards = []; // Tableau pour stocker toutes les cartes
        let currentDeck = ''; // Nom du paquet actuellement charg√©
        
        // Variables pour la s√©lection
        let selectedCards = new Set(); // Cartes s√©lectionn√©es
        let lastSelectedCard = null; // Derni√®re carte s√©lectionn√©e pour la s√©lection multiple
        
        // Variables pour les groupes
        let groups = new Map(); // Map: groupId -> { cards: Set, element: HTMLElement, name: string }
        let cardGroups = new Map(); // Map: cardId -> groupId
        let groupCounter = 0; // Compteur pour les IDs de groupes

        const canvas = document.getElementById('canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const zoomLevel = document.getElementById('zoom-level');
        const zoomInfo = document.getElementById('zoom-info');
        const position = document.getElementById('position');
        const contextMenu = document.getElementById('context-menu');
        const selectionToolbar = document.getElementById('selection-toolbar');
        const selectionCount = document.getElementById('selection-count');

        // ===== SYST√àME DE S√âLECTION =====
        
        // Met √† jour l'affichage de la s√©lection
        function updateSelectionDisplay() {
            const count = selectedCards.size;
            selectionCount.textContent = `${count} carte(s) s√©lectionn√©e(s)`;
            
            if (count > 0) {
                selectionToolbar.style.display = 'block';
            } else {
                selectionToolbar.style.display = 'none';
            }
        }
        
        // S√©lectionne ou d√©s√©lectionne une carte
        function toggleCardSelection(cardElement, forceState = null) {
            const cardId = cardElement.getAttribute('data-card-id');
            
            if (forceState === true || (forceState === null && !selectedCards.has(cardId))) {
                // S√©lectionner
                selectedCards.add(cardId);
                cardElement.classList.add('selected');
                lastSelectedCard = cardElement;
            } else {
                // D√©s√©lectionner
                selectedCards.delete(cardId);
                cardElement.classList.remove('selected');
                if (lastSelectedCard === cardElement) {
                    lastSelectedCard = null;
                }
            }
            
            updateSelectionDisplay();
        }
        
        // D√©s√©lectionne toutes les cartes
        function deselectAllCards() {
            selectedCards.forEach(cardId => {
                const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
                if (cardElement) {
                    cardElement.classList.remove('selected');
                }
            });
            selectedCards.clear();
            lastSelectedCard = null;
            updateSelectionDisplay();
        }
        
        // G√®re la s√©lection multiple avec Maj
        function handleCardClick(cardElement, event) {
            if (event.shiftKey && lastSelectedCard) {
                // S√©lection multiple : s√©lectionne toutes les cartes entre la derni√®re et celle-ci
                const allCards = Array.from(document.querySelectorAll('.card-box'));
                const lastIndex = allCards.indexOf(lastSelectedCard);
                const currentIndex = allCards.indexOf(cardElement);
                
                const startIndex = Math.min(lastIndex, currentIndex);
                const endIndex = Math.max(lastIndex, currentIndex);
                
                for (let i = startIndex; i <= endIndex; i++) {
                    toggleCardSelection(allCards[i], true);
                }
            } else if (event.ctrlKey || event.metaKey) {
                // Ajout/suppression √† la s√©lection avec Ctrl/Cmd
                toggleCardSelection(cardElement);
            } else {
                // S√©lection simple : d√©s√©lectionne tout et s√©lectionne seulement cette carte
                deselectAllCards();
                toggleCardSelection(cardElement, true);
            }
        }
        
        // Affiche le menu contextuel
        function showContextMenu(x, y, targetCard) {
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            contextMenu.style.display = 'block';
            contextMenu.targetCard = targetCard;
        }
        
        // Cache le menu contextuel
        function hideContextMenu() {
            contextMenu.style.display = 'none';
            contextMenu.targetCard = null;
        }

        // ===== SYST√àME DE GROUPES =====
        
        // Calcule les limites (bounds) d'un groupe bas√© sur ses cartes
        function calculateGroupBounds(cardIds) {
            if (cardIds.length === 0) return null;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            cardIds.forEach(cardId => {
                const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
                if (cardElement) {
                    const left = parseInt(cardElement.style.left) || 0;
                    const top = parseInt(cardElement.style.top) || 0;
                    
                    // Utilise les m√™mes dimensions fixes que le reste du syst√®me
                    const width = 300; // Largeur fixe des cartes (CSS)
                    const height = 200; // Hauteur fixe des cartes (CSS)
                    
                    minX = Math.min(minX, left);
                    minY = Math.min(minY, top);
                    maxX = Math.max(maxX, left + width);
                    maxY = Math.max(maxY, top + height);
                }
            });
            
            // Padding plus g√©n√©reux pour √©viter que la bordure passe sous les cartes
            const padding = 50;
            return {
                left: minX - padding,
                top: minY - padding,
                width: (maxX - minX) + (padding * 2),
                height: (maxY - minY) + (padding * 2)
            };
        }
        
        // Cr√©e un nouveau groupe
        function createGroup(cardIds, name = null) {
            if (cardIds.length < 2) {
                alert('Un groupe doit contenir au moins 2 cartes');
                return null;
            }
            
            const groupId = `group_${++groupCounter}`;
            const groupName = name || `Groupe ${groupCounter}`;
            
            // Retire les cartes de leurs groupes existants
            cardIds.forEach(cardId => {
                if (cardGroups.has(cardId)) {
                    removeCardFromGroup(cardId);
                }
            });
            
            // Calcule les dimensions du groupe
            const bounds = calculateGroupBounds(cardIds);
            if (!bounds) return null;
            
            // Cr√©e l'√©l√©ment visuel du groupe
            const groupElement = document.createElement('div');
            groupElement.className = 'group-box';
            groupElement.setAttribute('data-group-id', groupId);
            groupElement.style.left = bounds.left + 'px';
            groupElement.style.top = bounds.top + 'px';
            groupElement.style.width = bounds.width + 'px';
            groupElement.style.height = bounds.height + 'px';
            
            // Ajoute le label du groupe
            const label = document.createElement('div');
            label.className = 'group-label';
            label.textContent = groupName;
            label.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showGroupContextMenu(e.clientX, e.clientY, groupId);
            });
            groupElement.appendChild(label);
            
            // Ajoute le groupe au canvas
            canvas.appendChild(groupElement);
            
            // Met √† jour les structures de donn√©es
            const cardIdSet = new Set(cardIds);
            groups.set(groupId, {
                cards: cardIdSet,
                element: groupElement,
                name: groupName
            });
            
            // Met √† jour le z-index du groupe pour qu'il soit juste en dessous de ses cartes
            updateGroupZIndex(groupId);
            
            // Rend le groupe d√©pla√ßable
            makeGroupDraggable(groupElement, groupId);
            
            console.log(`Groupe "${groupName}" cr√©√© avec ${cardIds.length} cartes`);
            return groupId;
        }
        
        // Met √† jour les dimensions et position d'un groupe
        function updateGroupBounds(groupId) {
            const group = groups.get(groupId);
            if (!group) return;
            
            const cardIds = Array.from(group.cards);
            const bounds = calculateGroupBounds(cardIds);
            
            if (bounds) {
                // V√©rifie que les nouvelles dimensions sont valides
                if (bounds.width > 0 && bounds.height > 0) {
                    group.element.style.left = bounds.left + 'px';
                    group.element.style.top = bounds.top + 'px';
                    group.element.style.width = bounds.width + 'px';
                    group.element.style.height = bounds.height + 'px';
                }
            }
        }
        
        // Supprime un groupe
        function deleteGroup(groupId) {
            const group = groups.get(groupId);
            if (!group) return;
            
            // Retire les cartes du groupe
            group.cards.forEach(cardId => {
                cardGroups.delete(cardId);
            });
            
            // Supprime l'√©l√©ment visuel
            if (group.element && group.element.parentNode) {
                group.element.parentNode.removeChild(group.element);
            }
            
            // Supprime de la structure de donn√©es
            groups.delete(groupId);
            
            console.log(`Groupe "${group.name}" supprim√©`);
        }
        
        // Retire une carte d'un groupe
        function removeCardFromGroup(cardId) {
            const groupId = cardGroups.get(cardId);
            if (!groupId) return;
            
            const group = groups.get(groupId);
            if (!group) return;
            
            group.cards.delete(cardId);
            cardGroups.delete(cardId);
            
            // Si le groupe n'a plus assez de cartes, le supprimer
            if (group.cards.size < 2) {
                deleteGroup(groupId);
            } else {
                updateGroupBounds(groupId);
            }
        }
        
        // Met √† jour le z-index d'un groupe pour qu'il soit juste en dessous de ses cartes
        function updateGroupZIndex(groupId) {
            const group = groups.get(groupId);
            if (!group) return;
            
            let minCardZIndex = Infinity;
            
            // Trouve le z-index le plus bas parmi les cartes du groupe
            group.cards.forEach(cardId => {
                const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
                if (cardElement) {
                    const cardZIndex = parseInt(cardElement.style.zIndex) || 1;
                    minCardZIndex = Math.min(minCardZIndex, cardZIndex);
                }
            });
            
            // Le groupe a un z-index juste en dessous de sa carte la plus basse
            if (group.element) {
                group.element.style.zIndex = Math.max(1, minCardZIndex - 1);
            }
        }
        
        // Met √† jour tous les groupes quand les cartes bougent
        function updateAllGroups() {
            groups.forEach((group, groupId) => {
                updateGroupBounds(groupId);
                updateGroupZIndex(groupId);
            });
        }
        
        // Affiche le menu contextuel pour un groupe
        function showGroupContextMenu(x, y, groupId) {
            // Pour l'instant, utilisons le m√™me menu que les cartes
            // Nous pourrions cr√©er un menu sp√©cifique aux groupes plus tard
            const group = groups.get(groupId);
            if (group) {
                showContextMenu(x, y, { isGroup: true, groupId: groupId, element: group.element });
            }
        }
        
        // Rend un groupe d√©pla√ßable
        function makeGroupDraggable(groupElement, groupId) {
            let isDragging = false;
            let startX, startY;
            let initialCardPositions = new Map(); // Stocke les positions initiales des cartes
            let hasMoved = false;

            groupElement.addEventListener('mousedown', (e) => {
                // Gestion du clic droit pour le menu contextuel
                if (e.button === 2) {
                    e.preventDefault();
                    e.stopPropagation();
                    showGroupContextMenu(e.clientX, e.clientY, groupId);
                    return;
                }
                
                // Gestion du clic gauche
                if (e.button === 0) {
                    isDragging = true;
                    hasMoved = false;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    // Stocke les positions initiales de toutes les cartes du groupe
                    const group = groups.get(groupId);
                    if (group) {
                        group.cards.forEach(cardId => {
                            const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
                            if (cardElement) {
                                initialCardPositions.set(cardId, {
                                    left: parseInt(cardElement.style.left) || 0,
                                    top: parseInt(cardElement.style.top) || 0
                                });
                            }
                        });
                        
                        // Stocke aussi la position initiale du groupe
                        initialCardPositions.set('group', {
                            left: parseInt(groupElement.style.left) || 0,
                            top: parseInt(groupElement.style.top) || 0
                        });
                    }
                    
                    // Am√®ne le groupe au premier plan et ajoute la classe dragging
                    // Le groupe garde son z-index relatif √† ses cartes
                    groupElement.classList.add('dragging');
                    
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Emp√™che le menu contextuel par d√©faut du navigateur
            groupElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = (e.clientX - startX) / zoom;
                    const deltaY = (e.clientY - startY) / zoom;
                    
                    // Si on bouge de plus de 5px, on consid√®re que c'est un drag
                    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                        hasMoved = true;
                    }
                    
                    // D√©place toutes les cartes du groupe en utilisant leurs positions initiales
                    const group = groups.get(groupId);
                    if (group) {
                        group.cards.forEach(cardId => {
                            const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
                            if (cardElement) {
                                const initialPos = initialCardPositions.get(cardId);
                                if (initialPos) {
                                    cardElement.style.left = (initialPos.left + deltaX) + 'px';
                                    cardElement.style.top = (initialPos.top + deltaY) + 'px';
                                }
                            }
                        });
                        
                        // D√©place le groupe directement avec le m√™me delta (plus rapide que recalculer)
                        const initialGroupPos = initialCardPositions.get('group');
                        if (initialGroupPos) {
                            groupElement.style.left = (initialGroupPos.left + deltaX) + 'px';
                            groupElement.style.top = (initialGroupPos.top + deltaY) + 'px';
                        }
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    
                    // Retire la classe dragging
                    groupElement.classList.remove('dragging');
                    
                    // Met √† jour les bounds du groupe apr√®s le d√©placement
                    if (hasMoved) {
                        setTimeout(() => updateGroupBounds(groupId), 50);
                    }
                }
            });
        }

        // Fonction pour sauvegarder les positions des cartes
        function saveCardPositions() {
            if (cards.length === 0) {
                alert('Aucune carte √† sauvegarder.');
                return;
            }

            const positions = {};
            const decks = new Set(); // Pour tracker tous les decks pr√©sents

            cards.forEach(card => {
                const cardId = card.getAttribute('data-card-id');
                positions[cardId] = {
                    left: parseInt(card.style.left) || 0,
                    top: parseInt(card.style.top) || 0,
                    zIndex: parseInt(card.style.zIndex) || 1
                };
                // Essaie de deviner le deck de chaque carte (bas√© sur le dernier deck import√©)
                decks.add(currentDeck || 'mixed');
            });

            // Sauvegarde des groupes
            const groupsData = {};
            groups.forEach((group, groupId) => {
                groupsData[groupId] = {
                    name: group.name,
                    cards: Array.from(group.cards)
                };
            });

            const saveData = {
                deck: currentDeck || 'mixed', // Garde la compatibilit√© avec l'ancien format
                decks: Array.from(decks), // Nouvelle info : tous les decks pr√©sents
                canvas: { x: canvasX, y: canvasY, zoom: zoom },
                cards: positions,
                groups: groupsData // Nouveau : sauvegarde des groupes
            };

            fetch('/save_positions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(saveData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('‚úÖ Positions et groupes sauvegard√©s !');
                } else {
                    alert('‚ùå Erreur lors de la sauvegarde: ' + data.error);
                }
            })
            .catch(error => {
                alert('‚ùå Erreur de communication: ' + error);
            });
        }

        // Fonction pour charger les positions des cartes
        function loadCardPositions() {
            if (!currentDeck) return;

            fetch('/load_positions')
            .then(response => response.json())
            .then(data => {
                if (data.success && data.positions.deck === currentDeck) {
                    const savedData = data.positions;
                    
                    // Restaure la position et le zoom du canvas
                    if (savedData.canvas) {
                        canvasX = savedData.canvas.x || 0;
                        canvasY = savedData.canvas.y || 0;
                        zoom = savedData.canvas.zoom || 1;
                        updateCanvasTransform();
                    }

                    // Restaure les positions des cartes
                    if (savedData.cards) {
                        cards.forEach(card => {
                            const cardId = card.getAttribute('data-card-id');
                            const savedPos = savedData.cards[cardId];
                            if (savedPos) {
                                card.style.left = savedPos.left + 'px';
                                card.style.top = savedPos.top + 'px';
                                card.style.zIndex = savedPos.zIndex || 1;
                                cardCounter = Math.max(cardCounter, savedPos.zIndex || 1);
                            }
                        });
                    }

                    // Restaure les groupes
                    if (savedData.groups) {
                        // Supprime les groupes existants
                        groups.forEach((group, groupId) => {
                            if (group.element && group.element.parentNode) {
                                group.element.parentNode.removeChild(group.element);
                            }
                        });
                        groups.clear();
                        cardGroups.clear();
                        groupCounter = 0;

                        // Recr√©e les groupes sauvegard√©s
                        Object.keys(savedData.groups).forEach(groupId => {
                            const groupData = savedData.groups[groupId];
                            const cardIds = groupData.cards;
                            
                            // V√©rifie que toutes les cartes du groupe existent
                            const existingCardIds = cardIds.filter(cardId => 
                                document.querySelector(`[data-card-id="${cardId}"]`)
                            );
                            
                            if (existingCardIds.length >= 2) {
                                createGroup(existingCardIds, groupData.name);
                            }
                        });
                    }

                    console.log('Positions et groupes restaur√©s pour le paquet:', currentDeck);
                }
            })
            .catch(error => {
                console.error('Erreur lors du chargement des positions:', error);
            });
        }

        // Fonction pour charger toutes les cartes sauvegard√©es
        function loadAllSavedCardsOnStartup() {
            fetch('/load_positions')
            .then(response => response.json())
            .then(data => {
                if (data.success && data.positions.cards) {
                    const savedCards = data.positions.cards;
                    const cardIds = Object.keys(savedCards);
                    
                    if (cardIds.length === 0) {
                        console.log('Aucune carte sauvegard√©e trouv√©e');
                        return;
                    }
                    
                    // R√©cup√®re les informations de toutes les cartes sauvegard√©es
                    fetch('/get_cards_by_ids', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ card_ids: cardIds })
                    })
                    .then(response => response.json())
                    .then(cardsData => {
                        if (cardsData.success && cardsData.cards.length > 0) {
                            // Vide le canvas au cas o√π
                            canvas.innerHTML = '';
                            cards = [];
                            
                            // Recr√©e toutes les cartes
                            cardsData.cards.forEach(card => {
                                const cardBox = document.createElement('div');
                                cardBox.className = 'card-box';
                                cardBox.setAttribute('data-card-id', card.card_id);
                                
                                // Applique les positions sauvegard√©es
                                const savedPos = savedCards[card.card_id];
                                cardBox.style.left = savedPos.left + 'px';
                                cardBox.style.top = savedPos.top + 'px';
                                cardBox.style.zIndex = savedPos.zIndex || 1;
                                cardCounter = Math.max(cardCounter, savedPos.zIndex || 1);
                                
                                let content = '';
                                for (const [field, text] of Object.entries(card.texts)) {
                                    content += `<strong>${field}:</strong><p>${text}</p>`;
                                }
                                card.images.forEach(imgPath => {
                                    content += `<img src="${imgPath}" alt="Image de la carte">`;
                                });

                                cardBox.innerHTML = content;
                                canvas.appendChild(cardBox);
                                cards.push(cardBox);
                                makeDraggable(cardBox);
                            });
                            
                            // Restaure la vue du canvas
                            if (data.positions.canvas) {
                                canvasX = data.positions.canvas.x || 0;
                                canvasY = data.positions.canvas.y || 0;
                                zoom = data.positions.canvas.zoom || 1;
                                updateCanvasTransform();
                            }
                            
                            console.log(`${cardsData.cards.length} cartes restaur√©es depuis la sauvegarde`);
                            
                            // Met le select sur le dernier deck pour la compatibilit√©
                            if (data.positions.deck) {
                                const deckSelect = document.getElementById('deck-name');
                                deckSelect.value = data.positions.deck;
                                currentDeck = data.positions.deck;
                            }
                            
                            // Restaure les groupes sauvegard√©s
                            if (data.positions.groups) {
                                // Supprime les groupes existants
                                groups.forEach((group, groupId) => {
                                    if (group.element && group.element.parentNode) {
                                        group.element.parentNode.removeChild(group.element);
                                    }
                                });
                                groups.clear();
                                cardGroups.clear();
                                groupCounter = 0;

                                // Recr√©e les groupes sauvegard√©s
                                Object.keys(data.positions.groups).forEach(groupId => {
                                    const groupData = data.positions.groups[groupId];
                                    const cardIds = groupData.cards;
                                    
                                    // V√©rifie que toutes les cartes du groupe existent
                                    const existingCardIds = cardIds.filter(cardId => 
                                        document.querySelector(`[data-card-id="${cardId}"]`)
                                    );
                                    
                                    if (existingCardIds.length >= 2) {
                                        createGroup(existingCardIds, groupData.name);
                                    }
                                });
                            }
                        }
                    });
                }
            })
            .catch(error => {
                console.error('Erreur lors du chargement des cartes sauvegard√©es:', error);
            });
        }

        // Fonction pour restaurer toutes les cartes sauvegard√©es (sans se limiter √† un deck)
        function loadAllSavedCards() {
            fetch('/load_positions')
            .then(response => response.json())
            .then(data => {
                if (data.success && data.positions.cards) {
                    const savedCards = data.positions.cards;
                    
                    // Pour chaque carte sauvegard√©e, on essaie de la retrouver et la positionner
                    Object.keys(savedCards).forEach(cardId => {
                        const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
                        if (cardElement) {
                            const savedPos = savedCards[cardId];
                            cardElement.style.left = savedPos.left + 'px';
                            cardElement.style.top = savedPos.top + 'px';
                            cardElement.style.zIndex = savedPos.zIndex || 1;
                            cardCounter = Math.max(cardCounter, savedPos.zIndex || 1);
                        }
                    });

                    // Restaure aussi le canvas
                    if (data.positions.canvas) {
                        canvasX = data.positions.canvas.x || 0;
                        canvasY = data.positions.canvas.y || 0;
                        zoom = data.positions.canvas.zoom || 1;
                        updateCanvasTransform();
                    }

                    console.log('Toutes les cartes sauvegard√©es ont √©t√© repositionn√©es');
                }
            })
            .catch(error => {
                console.error('Erreur lors du chargement des cartes sauvegard√©es:', error);
            });
        }

        // Fonction pour v√©rifier si deux rectangles se chevauchent
        function isOverlapping(rect1, rect2) {
            return !(rect1.right < rect2.left || 
                     rect2.right < rect1.left || 
                     rect1.bottom < rect2.top || 
                     rect2.bottom < rect1.top);
        }

        // Fonction pour obtenir les dimensions d'une carte
        function getCardRect(cardElement) {
            const left = parseInt(cardElement.style.left) || 0;
            const top = parseInt(cardElement.style.top) || 0;
            const width = 300; // largeur fixe des cartes
            const height = 200; // hauteur fixe des cartes
            
            return {
                left: left,
                top: top,
                right: left + width,
                bottom: top + height,
                centerX: left + width / 2,
                centerY: top + height / 2
            };
        }

        // Variables globales pour la physique
        let isRepelling = false; // Flag pour √©viter les conflits de r√©pulsion

        // Fonction pour repousser les cartes qui se chevauchent
        function repelOverlappingCards() {
            physicsRepulsion();
        }

        // Syst√®me de r√©pulsion physique am√©lior√©
        function physicsRepulsion() {
            if (isRepelling) return;
            isRepelling = true;

            let hasOverlaps = true;
            let iterations = 0;
            const maxIterations = 50;

            function repelStep() {
                hasOverlaps = false;
                const forces = new Map();

                // Initialise les forces pour chaque carte
                cards.forEach(card => {
                    forces.set(card, { x: 0, y: 0 });
                });

                // Calcule les forces de r√©pulsion entre toutes les paires de cartes
                for (let i = 0; i < cards.length; i++) {
                    for (let j = i + 1; j < cards.length; j++) {
                        const card1 = cards[i];
                        const card2 = cards[j];
                        const rect1 = getCardRect(card1);
                        const rect2 = getCardRect(card2);
                        
                        if (isOverlapping(rect1, rect2)) {
                            hasOverlaps = true;
                            
                            // Calcule la direction et distance de r√©pulsion
                            const deltaX = rect2.centerX - rect1.centerX;
                            const deltaY = rect2.centerY - rect1.centerY;
                            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                            
                            if (distance === 0) {
                                // Si les cartes sont exactement au m√™me endroit
                                const force1 = forces.get(card1);
                                const force2 = forces.get(card2);
                                force1.x -= 30;
                                force1.y -= 30;
                                force2.x += 30;
                                force2.y += 30;
                            } else {
                                // Calcule la force de r√©pulsion n√©cessaire pour s√©parer les cartes
                                const overlapX = Math.max(0, (300) - Math.abs(deltaX));
                                const overlapY = Math.max(0, (200) - Math.abs(deltaY));
                                const overlap = overlapX + overlapY;
                                
                                const forceStrength = Math.min(40, overlap * 0.3 + 15);
                                const normalX = deltaX / distance;
                                const normalY = deltaY / distance;
                                
                                const force1 = forces.get(card1);
                                const force2 = forces.get(card2);
                                
                                force1.x -= normalX * forceStrength;
                                force1.y -= normalY * forceStrength;
                                force2.x += normalX * forceStrength;
                                force2.y += normalY * forceStrength;
                            }
                        }
                    }
                }

                // Applique les forces calcul√©es avec une animation smooth
                forces.forEach((force, card) => {
                    if (Math.abs(force.x) > 0.1 || Math.abs(force.y) > 0.1) {
                        const currentLeft = parseInt(card.style.left) || 0;
                        const currentTop = parseInt(card.style.top) || 0;
                        
                        // Applique un facteur d'amortissement pour des mouvements plus fluides
                        const dampening = 0.7;
                        card.style.left = (currentLeft + force.x * dampening) + 'px';
                        card.style.top = (currentTop + force.y * dampening) + 'px';
                    }
                });

                iterations++;
                
                // Continue la simulation si il y a encore des chevauchements
                if (hasOverlaps && iterations < maxIterations) {
                    setTimeout(repelStep, 80); // D√©lai pour l'animation
                } else {
                    isRepelling = false;
                    // Met √† jour les groupes apr√®s la r√©pulsion
                    updateAllGroups();
                }
            }

            repelStep();
        }

        // Fonction pour mettre √† jour la transformation du canvas
        function updateCanvasTransform() {
            canvas.style.transform = `translate(${canvasX}px, ${canvasY}px) scale(${zoom})`;
            zoomLevel.textContent = Math.round(zoom * 100) + '%';
            zoomInfo.textContent = Math.round(zoom * 100) + '%';
            position.textContent = `${Math.round(-canvasX)}, ${Math.round(-canvasY)}`;
        }

        // Gestion du zoom avec la molette
        canvasContainer.addEventListener('wheel', (e) => {
            // V√©rifie si la souris est au-dessus d'une carte
            const target = e.target;
            const cardBox = target.closest('.card-box');
            
            if (cardBox) {
                // Si on est sur une carte, laisse le comportement de scroll normal de la carte
                // Ne pas preventDefault() pour permettre le scroll du contenu de la carte
                return;
            }
            
            // Sinon, zoom sur le canvas
            e.preventDefault();
            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const oldZoom = zoom;
            const zoomFactor = e.deltaY < 0 ? 1.05 : 0.95;
            zoom = Math.max(0.1, Math.min(3, zoom * zoomFactor));
            
            // Ajuste la position pour zoomer vers la souris
            const zoomChange = zoom / oldZoom;
            canvasX = mouseX - (mouseX - canvasX) * zoomChange;
            canvasY = mouseY - (mouseY - canvasY) * zoomChange;
            
            updateCanvasTransform();
        });

        // Gestion du d√©placement du canvas
        canvasContainer.addEventListener('mousedown', (e) => {
            if (e.target === canvasContainer || e.target === canvas) {
                isDraggingCanvas = true;
                canvasContainer.classList.add('dragging');
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingCanvas) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                canvasX += deltaX;
                canvasY += deltaY;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                updateCanvasTransform();
            }
        });

        document.addEventListener('mouseup', () => {
            isDraggingCanvas = false;
            canvasContainer.classList.remove('dragging');
        });

        // Contr√¥les de zoom
        document.getElementById('zoom-in').addEventListener('click', () => {
            zoom = Math.min(3, zoom * 1.1);
            updateCanvasTransform();
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            zoom = Math.max(0.1, zoom * 0.9);
            updateCanvasTransform();
        });

        document.getElementById('reset-view').addEventListener('click', () => {
            canvasX = 0;
            canvasY = 0;
            zoom = 1;
            updateCanvasTransform();
        });

        // Fonction pour rendre une carte d√©pla√ßable
        function makeDraggable(element) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            let hasMoved = false; // Pour distinguer clic et drag

            element.addEventListener('mousedown', (e) => {
                // Gestion du clic droit pour le menu contextuel
                if (e.button === 2) {
                    e.preventDefault();
                    e.stopPropagation();
                    showContextMenu(e.clientX, e.clientY, element);
                    return;
                }
                
                // Gestion du clic gauche
                if (e.button === 0) {
                    isDragging = true;
                    hasMoved = false;
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = parseInt(element.style.left) || 0;
                    startTop = parseInt(element.style.top) || 0;
                    element.style.zIndex = Math.max(++cardCounter, 10); // Toujours au moins 10 pour √™tre au-dessus des groupes
                    
                    // D√©sactive temporairement les transitions pendant le drag
                    element.style.transition = 'none';
                    
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            element.addEventListener('click', (e) => {
                // G√®re la s√©lection seulement si on n'a pas boug√© la carte
                if (!hasMoved) {
                    handleCardClick(element, e);
                }
                e.stopPropagation();
            });

            // Emp√™che le menu contextuel par d√©faut du navigateur
            element.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = (e.clientX - startX) / zoom;
                    const deltaY = (e.clientY - startY) / zoom;
                    
                    // Si on bouge de plus de 5px, on consid√®re que c'est un drag
                    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                        hasMoved = true;
                    }
                    
                    element.style.left = (startLeft + deltaX) + 'px';
                    element.style.top = (startTop + deltaY) + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    
                    // R√©active les transitions pour l'animation de r√©pulsion
                    element.style.transition = 'left 0.3s ease-out, top 0.3s ease-out, border-color 0.2s ease';
                    
                    // V√©rifie et repousse les cartes qui se chevauchent apr√®s le d√©placement
                    if (hasMoved) {
                        setTimeout(() => {
                            repelOverlappingCards();
                            updateAllGroups(); // Met √† jour les groupes apr√®s le d√©placement
                        }, 50);
                    } else {
                        // M√™me si la carte n'a pas boug√©, met √† jour le z-index du groupe si elle en fait partie
                        const cardId = element.getAttribute('data-card-id');
                        if (cardGroups.has(cardId)) {
                            const groupId = cardGroups.get(cardId);
                            updateGroupZIndex(groupId);
                        }
                    }
                }
            });
        }

        // Fonction pour calculer les limites des cartes existantes
        function getExistingCardsBounds() {
            if (cards.length === 0) {
                return { minX: 0, maxY: 0 };
            }
            
            let minX = Infinity;
            let maxY = -Infinity;
            
            cards.forEach(card => {
                const left = parseInt(card.style.left) || 0;
                const top = parseInt(card.style.top) || 0;
                const height = card.offsetHeight || 220; // hauteur par d√©faut
                
                minX = Math.min(minX, left);
                maxY = Math.max(maxY, top + height);
            });
            
            return { minX: minX === Infinity ? 0 : minX, maxY };
        }

        // Fonction pour importer un paquet
        function importDeck(deckName) {
            currentDeck = deckName; // Met √† jour le paquet actuel
            
            // Ne vide PAS le canvas - garde les cartes existantes
            // canvas.innerHTML = '';
            // cards = [];
            
            fetch('/import_deck', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `deck_name=${encodeURIComponent(deckName)}`
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert(`Erreur: ${data.error}`);
                    return;
                }
                if (data.length === 0) {
                    alert('Aucune carte trouv√©e.');
                    return;
                }

                // Calcule la position de d√©part pour les nouvelles cartes
                const bounds = getExistingCardsBounds();
                const startX = bounds.minX;
                const startY = bounds.maxY + 20; // 20px d'espacement

                data.forEach((card, index) => {
                    const cardBox = document.createElement('div');
                    cardBox.className = 'card-box';
                    cardBox.setAttribute('data-card-id', card.card_id);
                    
                    // Position en grille (4 par rang√©e) √† partir de la position calcul√©e
                    const cardsPerRow = 4;
                    const cardWidth = 320;
                    const cardHeight = 220;
                    const col = index % cardsPerRow;
                    const row = Math.floor(index / cardsPerRow);
                    
                    cardBox.style.left = (startX + col * cardWidth) + 'px';
                    cardBox.style.top = (startY + row * cardHeight) + 'px';
                    cardBox.style.zIndex = ++cardCounter;
                    
                    let content = '';
                    for (const [field, text] of Object.entries(card.texts)) {
                        content += `<strong>${field}:</strong><p>${text}</p>`;
                    }
                    card.images.forEach(imgPath => {
                        content += `<img src="${imgPath}" alt="Image de la carte">`;
                    });

                    cardBox.innerHTML = content;
                    canvas.appendChild(cardBox);
                    cards.push(cardBox); // Ajoute la carte au tableau
                    makeDraggable(cardBox);
                });
                
                // Charge les positions sauvegard√©es apr√®s avoir cr√©√© toutes les cartes
                // Seulement si c'est le premier import (canvas vide au d√©part)
                setTimeout(() => {
                    if (bounds.maxY === 0) { // Si c'√©tait le premier import
                        loadCardPositions();
                    }
                }, 200);
                
                // Applique la r√©pulsion apr√®s avoir charg√© toutes les cartes (si pas de positions sauv√©es)
                setTimeout(() => physicsRepulsion(), 300);
            })
            .catch(error => {
                alert('Erreur de communication.');
                console.error('Erreur:', error);
            });
        }

        // Gestion du formulaire d'import
        document.getElementById('import-form').addEventListener('submit', function(event) {
            event.preventDefault();
            const deckName = document.getElementById('deck-name').value;
            importDeck(deckName);
        });

        // Gestionnaire pour le bouton de sauvegarde
        document.getElementById('save-positions').addEventListener('click', saveCardPositions);

        // Gestionnaire pour le bouton vider le canvas
        document.getElementById('clear-canvas').addEventListener('click', function() {
            if (confirm('Voulez-vous vraiment vider le canvas ? Toutes les cartes seront supprim√©es.')) {
                canvas.innerHTML = '';
                cards = [];
                currentDeck = '';
                cardCounter = 0;
                deselectAllCards(); // Vide aussi la s√©lection
                
                // Vide aussi les groupes
                groups.clear();
                cardGroups.clear();
                groupCounter = 0;
            }
        });

        // ===== GESTIONNAIRES D'√âV√âNEMENTS POUR LA S√âLECTION =====
        
        // Menu contextuel - D√©s√©lectionner
        document.getElementById('context-deselect').addEventListener('click', () => {
            if (contextMenu.targetCard) {
                toggleCardSelection(contextMenu.targetCard, false);
            }
            hideContextMenu();
        });
        
        // Menu contextuel - Supprimer
        document.getElementById('context-delete').addEventListener('click', () => {
            if (contextMenu.targetCard) {
                if (contextMenu.targetCard.isGroup) {
                    // Supprimer un groupe
                    deleteGroup(contextMenu.targetCard.groupId);
                } else {
                    // Supprimer une carte
                    const cardId = contextMenu.targetCard.getAttribute('data-card-id');
                    selectedCards.delete(cardId);
                    cards = cards.filter(card => card !== contextMenu.targetCard);
                    
                    // Retire la carte de son groupe si elle en fait partie
                    if (cardGroups.has(cardId)) {
                        removeCardFromGroup(cardId);
                    }
                    
                    contextMenu.targetCard.remove();
                    updateSelectionDisplay();
                }
            }
            hideContextMenu();
        });
        
        // Menu contextuel - Mettre au premier plan
        document.getElementById('context-bring-front').addEventListener('click', () => {
            if (contextMenu.targetCard) {
                contextMenu.targetCard.style.zIndex = ++cardCounter;
            }
            hideContextMenu();
        });
        
        // Barre d'outils - Grouper
        document.getElementById('group-selected').addEventListener('click', () => {
            if (selectedCards.size >= 2) {
                const cardIds = Array.from(selectedCards);
                const groupId = createGroup(cardIds);
                if (groupId) {
                    deselectAllCards(); // D√©s√©lectionne les cartes apr√®s groupement
                }
            } else {
                alert('S√©lectionnez au moins 2 cartes pour cr√©er un groupe');
            }
        });
        
        // Barre d'outils - Tout d√©s√©lectionner
        document.getElementById('deselect-all').addEventListener('click', () => {
            deselectAllCards();
        });
        
        // Clic global pour cacher le menu contextuel et d√©s√©lectionner
        document.addEventListener('click', (e) => {
            // Cache le menu contextuel si on clique ailleurs
            if (!contextMenu.contains(e.target)) {
                hideContextMenu();
            }
            
            // D√©s√©lectionne tout si on clique sur le canvas (pas sur une carte)
            if (e.target === canvas || e.target === canvasContainer) {
                deselectAllCards();
            }
        });
        
        // Emp√™che la propagation des clics dans les barres d'outils
        document.getElementById('toolbar').addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        document.getElementById('zoom-controls').addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        selectionToolbar.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        contextMenu.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // Emp√™che le zoom/pan accidentel du navigateur
        document.addEventListener('keydown', function(e) {
            // Emp√™che Ctrl+Zoom et autres raccourcis de zoom
            if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '0' || e.key === '=' || e.wheelDelta)) {
                e.preventDefault();
            }
            // Emp√™che les fl√®ches de d√©placer la page
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'PageUp', 'PageDown', 'Home', 'End'].includes(e.key)) {
                // Ne pas emp√™cher si on est dans un champ de saisie
                if (!['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) {
                    e.preventDefault();
                }
            }
        });

        // Emp√™che le zoom par pincement sur mobile/trackpad
        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });
        document.addEventListener('gesturechange', function(e) {
            e.preventDefault();
        });
        document.addEventListener('gestureend', function(e) {
            e.preventDefault();
        });

        // Initialisation
        updateCanvasTransform();
        
        // Charge automatiquement toutes les cartes sauvegard√©es au chargement de la page
        window.addEventListener('load', () => {
            loadAllSavedCardsOnStartup();
        });
    </script>

</body>
</html>
